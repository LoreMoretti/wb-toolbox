{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Whole-Body Toolbox \u00b6 A Simulink Toolbox for Whole-Body Control \u00b6 \u200b This toolbox allows non-programming experts and researchers approaching Whole-Body Control to more easily develop controllers on either simulated or real YARP -based robotic platforms. \u200b Develop to deployment time is minimized by exploiting the rich variety of Simulink's toolboxes and its capabilities on rapid prototyping and visual debugging. WBT is based on the dataflow framework blockfactory . It mainly wraps functionalities of the YARP middleware and the iDynTree rigid-body dynamics library, providing an interface compatible with dataflow programming. The WBT library can be embedded in any C++ framework and run from all the engines supported by blockfactory , we mainly use and support Simulink by providing a Simulink Library. Who uses WBT ? \u00b6 WBT is used extensively in the controllers stored in robotology/whole-body-controllers . This video shows the latest results on the iCub robot achieved in the EU project CoDyCo in which a top level controller implemented with the robotology/wb-toolbox achieves a running 100 Hz rate. Citing this work \u00b6 Romano F., Traversaro S., Pucci D., Nori F. A Whole-Body Software Abstraction layer for Control Design of free-floating Mechanical Systems Journal of Software Engineering for Robotics, 2017 Bibtex citation @ARTICLE{RomanoWBI17Journal, author={F. Romano and S. Traversaro and D. Pucci and F. Nori}, journal={Journal of Software Engineering for Robotics}, title={A Whole-Body Software Abstraction layer for Control Design of free-floating Mechanical Systems}, year={2017}, }","title":"Home"},{"location":"#whole-body-toolbox","text":"","title":"Whole-Body Toolbox"},{"location":"#a-simulink-toolbox-for-whole-body-control","text":"\u200b This toolbox allows non-programming experts and researchers approaching Whole-Body Control to more easily develop controllers on either simulated or real YARP -based robotic platforms. \u200b Develop to deployment time is minimized by exploiting the rich variety of Simulink's toolboxes and its capabilities on rapid prototyping and visual debugging. WBT is based on the dataflow framework blockfactory . It mainly wraps functionalities of the YARP middleware and the iDynTree rigid-body dynamics library, providing an interface compatible with dataflow programming. The WBT library can be embedded in any C++ framework and run from all the engines supported by blockfactory , we mainly use and support Simulink by providing a Simulink Library.","title":"A Simulink Toolbox for Whole-Body Control"},{"location":"#who-uses-wbt","text":"WBT is used extensively in the controllers stored in robotology/whole-body-controllers . This video shows the latest results on the iCub robot achieved in the EU project CoDyCo in which a top level controller implemented with the robotology/wb-toolbox achieves a running 100 Hz rate.","title":"Who uses WBT?"},{"location":"#citing-this-work","text":"Romano F., Traversaro S., Pucci D., Nori F. A Whole-Body Software Abstraction layer for Control Design of free-floating Mechanical Systems Journal of Software Engineering for Robotics, 2017 Bibtex citation @ARTICLE{RomanoWBI17Journal, author={F. Romano and S. Traversaro and D. Pucci and F. Nori}, journal={Journal of Software Engineering for Robotics}, title={A Whole-Body Software Abstraction layer for Control Design of free-floating Mechanical Systems}, year={2017}, }","title":"Citing this work"},{"location":"Migration_from_WB-Toolbox_2.0/","text":"From WB-Toolbox 2.0 to WB-Toolbox 3.* \u00b6 Most of the major changes delivered with the 3.0 version of the WB-Toolbox don't affect directly the end-user. Under the hood the toolbox had an important polishing, and the small manual intervention required by this new release match the new features which have been developed. You can read Release Notes for a detailed overview. Below are described only the steps required to port Simulink models to this new release. New toolbox configuration \u00b6 The WB-Toolbox 2.0 was based on top of yarpWholeBodyInterface , which configuration was stored in a yarpWholeBodyInterface.ini file. This file was retrieved by ResourceFinder and its information was then loaded into the toolbox. Store the configuration in the Simulink model \u00b6 WB-Toolbox 3.0 deprecated the support of yarpWholeBodyInterface , and for reducing the complexity and sparsity of the information storage it allows configuring a Simulink model from the model itself. The new Configuration block allows inserting information such as Robot Name , URDF Name , Controlled Joints , ... directly from the block's mask. Load the configuration from the Workspace \u00b6 Sometimes it might be useful loading the model's configuration directly from the Workspace. For this purpose, a new WBToolbox.WBToolboxConfig class has been developed. The Configuration block needs to know only the name of the variable which refers to the object. Its data is then read before the simulation runs. This snippet of code shows an example of how to initialize a configuration object: # Initialize a config object WBTConfigRobot = WBToolbox . WBToolboxConfig ; # Insert robot data WBTConfigRobot . RobotName = 'icubSim' ; WBTConfigRobot . UrdfFile = 'model.urdf' ; WBTConfigRobot . ControlledJoints = { ... 'torso_pitch' , 'torso_roll' , 'torso_yaw' , ... 'r_shoulder_pitch' , 'r_shoulder_roll' , 'r_shoulder_yaw' , 'r_elbow' , ... 'l_shoulder_pitch' , 'l_shoulder_roll' , 'l_shoulder_yaw' , 'l_elbow' }; WBTConfigRobot . ControlBoardsNames = { 'torso' , 'left_arm' , 'right_arm' }; WBTConfigRobot . LocalName = 'WBT' ; To check if the data has been read correctly, it is displayed as read-only in the block's mask. Furthermore, a good sign for a valid configuration is the WBTConfigRobot.ValidConfiguration property. Multi-robot support \u00b6 The scope of the introduction of the Configuration block goes beyond the need of a simpler toolbox configuration. One of the biggest limitation of the 2.0 version is the support of controlling only one robot per model . WB-Toolbox 3.0 is now capable of reading / sending data from / to multiple robots. Multiple Configuration blocks can be present in the same model attaining to the following rules: In the same hierarchical level of a Simulink model, only one Configuration block should be present. In other words, you should never see in the display more than one Configuration block. Configuration blocks put deeper in the hierarchy (e.g. in a Subsystem) override the previous ones. There are a few pitfalls which are worth to be highlighted: It is legit having two Subsystems with different Configuration blocks which point to the same robot. They can have for instance a different joint list and use different control boards. Although, despite reading information never creates problems, sending data to the robot in such scenario can be disastrous. In fact, consider the case these two subsystems share one link, and configure it in two different control modes (e.g. Position and Torque). Sending references to this link causes unpredictable effects. In line of theory it would be possible to have two subsystems in which the first one refers to a Gazebo model and the second one to a real robot. However, this case causes unpredictable behaviour for what concerns the synchronization. In fact, two different blocks for such aim are present in the toolbox: Simulator Synchronizer and Real Time Syncronizer . They should be always used exclusively. Other manual edits \u00b6 All the Get Estimate blocks need to be replaced by the new Get Measurement block. All the hardcoded digital filters (e.g. for the joints velocities) have been removed. A new Discrete Filter block has been developed, and it should be manually added if the read raw signal (e.g. from the Get Measurement block) requires filtering. The C++ class used by the DoFs Converter changed. All the blocks in the YARP To WBI configuration need to be connected again. The gravity vector is stored is the WBToolboxConfig class. If an alternative value is needed, set it globally directly in the configuration object or scope the block which needs it in a Subsystem with its own Configuration block. In order to set the low level PIDs, loading in the Workspace a WBToolbox.WBTPIDConfig object should be configured as follows: # Initialize an empty object pids = WBToolbox . WBTPIDConfig ; # Insert data pids . addPID ( WBToolbox . PID ( 'l_elbow' , WBToolbox . PID ( 1 , 1 , 0 ))); pids . addPID ( WBToolbox . PID ( 'l_wrist_pitch' , WBToolbox . PID ( 1.5 , 0 , 0.1 ))); pids . addPID ( WBToolbox . PID ( 'r_shoulder_pitch' , WBToolbox . PID ( 0.2 , 0 , 0 ))); pids . addPID ( WBToolbox . PID ( 'torso_roll' , WBToolbox . PID ( 0.1 , 0.1 , 0 ))); If some of the controlled joints are not specified, the PIDs are kept in their default values. Deprecations \u00b6 Inverse Kinematics and Remote Inverse Kinematics have been temporary deprecated. They will see a major release in the coming months. If you need them please do not upgrade to the 3.0 version. Set Low Level PID block lost the capability of switching between multiple configurations. Since they were stored in an external file, this change is aligned to the simplification process chosen for for the configuration.","title":"From WB-Toolbox 2.0"},{"location":"Migration_from_WB-Toolbox_2.0/#from-wb-toolbox-20-to-wb-toolbox-3","text":"Most of the major changes delivered with the 3.0 version of the WB-Toolbox don't affect directly the end-user. Under the hood the toolbox had an important polishing, and the small manual intervention required by this new release match the new features which have been developed. You can read Release Notes for a detailed overview. Below are described only the steps required to port Simulink models to this new release.","title":"From WB-Toolbox 2.0 to WB-Toolbox 3.*"},{"location":"Migration_from_WB-Toolbox_2.0/#new-toolbox-configuration","text":"The WB-Toolbox 2.0 was based on top of yarpWholeBodyInterface , which configuration was stored in a yarpWholeBodyInterface.ini file. This file was retrieved by ResourceFinder and its information was then loaded into the toolbox.","title":"New toolbox configuration"},{"location":"Migration_from_WB-Toolbox_2.0/#store-the-configuration-in-the-simulink-model","text":"WB-Toolbox 3.0 deprecated the support of yarpWholeBodyInterface , and for reducing the complexity and sparsity of the information storage it allows configuring a Simulink model from the model itself. The new Configuration block allows inserting information such as Robot Name , URDF Name , Controlled Joints , ... directly from the block's mask.","title":"Store the configuration in the Simulink model"},{"location":"Migration_from_WB-Toolbox_2.0/#load-the-configuration-from-the-workspace","text":"Sometimes it might be useful loading the model's configuration directly from the Workspace. For this purpose, a new WBToolbox.WBToolboxConfig class has been developed. The Configuration block needs to know only the name of the variable which refers to the object. Its data is then read before the simulation runs. This snippet of code shows an example of how to initialize a configuration object: # Initialize a config object WBTConfigRobot = WBToolbox . WBToolboxConfig ; # Insert robot data WBTConfigRobot . RobotName = 'icubSim' ; WBTConfigRobot . UrdfFile = 'model.urdf' ; WBTConfigRobot . ControlledJoints = { ... 'torso_pitch' , 'torso_roll' , 'torso_yaw' , ... 'r_shoulder_pitch' , 'r_shoulder_roll' , 'r_shoulder_yaw' , 'r_elbow' , ... 'l_shoulder_pitch' , 'l_shoulder_roll' , 'l_shoulder_yaw' , 'l_elbow' }; WBTConfigRobot . ControlBoardsNames = { 'torso' , 'left_arm' , 'right_arm' }; WBTConfigRobot . LocalName = 'WBT' ; To check if the data has been read correctly, it is displayed as read-only in the block's mask. Furthermore, a good sign for a valid configuration is the WBTConfigRobot.ValidConfiguration property.","title":"Load the configuration from the Workspace"},{"location":"Migration_from_WB-Toolbox_2.0/#multi-robot-support","text":"The scope of the introduction of the Configuration block goes beyond the need of a simpler toolbox configuration. One of the biggest limitation of the 2.0 version is the support of controlling only one robot per model . WB-Toolbox 3.0 is now capable of reading / sending data from / to multiple robots. Multiple Configuration blocks can be present in the same model attaining to the following rules: In the same hierarchical level of a Simulink model, only one Configuration block should be present. In other words, you should never see in the display more than one Configuration block. Configuration blocks put deeper in the hierarchy (e.g. in a Subsystem) override the previous ones. There are a few pitfalls which are worth to be highlighted: It is legit having two Subsystems with different Configuration blocks which point to the same robot. They can have for instance a different joint list and use different control boards. Although, despite reading information never creates problems, sending data to the robot in such scenario can be disastrous. In fact, consider the case these two subsystems share one link, and configure it in two different control modes (e.g. Position and Torque). Sending references to this link causes unpredictable effects. In line of theory it would be possible to have two subsystems in which the first one refers to a Gazebo model and the second one to a real robot. However, this case causes unpredictable behaviour for what concerns the synchronization. In fact, two different blocks for such aim are present in the toolbox: Simulator Synchronizer and Real Time Syncronizer . They should be always used exclusively.","title":"Multi-robot support"},{"location":"Migration_from_WB-Toolbox_2.0/#other-manual-edits","text":"All the Get Estimate blocks need to be replaced by the new Get Measurement block. All the hardcoded digital filters (e.g. for the joints velocities) have been removed. A new Discrete Filter block has been developed, and it should be manually added if the read raw signal (e.g. from the Get Measurement block) requires filtering. The C++ class used by the DoFs Converter changed. All the blocks in the YARP To WBI configuration need to be connected again. The gravity vector is stored is the WBToolboxConfig class. If an alternative value is needed, set it globally directly in the configuration object or scope the block which needs it in a Subsystem with its own Configuration block. In order to set the low level PIDs, loading in the Workspace a WBToolbox.WBTPIDConfig object should be configured as follows: # Initialize an empty object pids = WBToolbox . WBTPIDConfig ; # Insert data pids . addPID ( WBToolbox . PID ( 'l_elbow' , WBToolbox . PID ( 1 , 1 , 0 ))); pids . addPID ( WBToolbox . PID ( 'l_wrist_pitch' , WBToolbox . PID ( 1.5 , 0 , 0.1 ))); pids . addPID ( WBToolbox . PID ( 'r_shoulder_pitch' , WBToolbox . PID ( 0.2 , 0 , 0 ))); pids . addPID ( WBToolbox . PID ( 'torso_roll' , WBToolbox . PID ( 0.1 , 0.1 , 0 ))); If some of the controlled joints are not specified, the PIDs are kept in their default values.","title":"Other manual edits"},{"location":"Migration_from_WB-Toolbox_2.0/#deprecations","text":"Inverse Kinematics and Remote Inverse Kinematics have been temporary deprecated. They will see a major release in the coming months. If you need them please do not upgrade to the 3.0 version. Set Low Level PID block lost the capability of switching between multiple configurations. Since they were stored in an external file, this change is aligned to the simplification process chosen for for the configuration.","title":"Deprecations"},{"location":"Migration_from_WBI-Toolbox_1.0/","text":"From WBI-Toolbox to WB-Toolbox 2.* \u00b6 Given a simulink model with some WBI-Toolbox blocks inside, the general procedure is to substitute each block with the corresponding one from WB-Toolbox 2.0 . However, there are some things the user should take care while doing this operation. This guide points out the main differences between the two toolboxes. For more information about the WBI-Toolbox, please have a look at the WBI-Toolbox README . This guide follows the WBI and WB Toolbox blocks partitioning in Simulink library. It is divided in the following sections: Required variables Utilities wholeBodyActuators wholeBodyModel wholeBodyStates Required variables \u00b6 As explained in the WB-Toolbox README , first of all the user should define the following variables: - WBT_modelName - WBT_wbiList - WBT_wbiFilename - WBT_robotName They have already meaningful default values. Nevertheless you should take a look at at least the following two variables: - WBT_modelname = 'matlabTorqueBalancing' or be careful that the default name does not conflicts with any other modules or YARP ports - WBT_wbiList = 'ROBOT_TORQUE_CONTROL_JOINTS_WITHOUT_PRONOSUP' if you simulate a 23-DoFs iCub robot Floating base position estimate \u00b6 In the WB-Toolbox the world-to-base homogeneous transformation matrix is not calculated inside each block, but it must be provided from the Simulink model as a block input. The world-to-base homogeneous transformation matrix is a 4x4 matrix that maps position and orientation of a rigid body from an initial frame of reference to another. For back-compatibility, the transformation happending under the hood in the WBI-Toolbox can be obtained using forward kinematics blocks as in the following example: where forward kinematics is used to compute the transformation matrices from world to the left foot and from world to the root link, while the desired transformation matrix is obtained as a matrices product, using the homogeneous transformation matrix properties. Utilities \u00b6 In this section the user should note that: - the Minimum Jerk Trajectory Generator block has now only the reference trajectory as input. The initial value is automatically taken at startup. - Yarp Read and some other blocks require now the WBT_modelName instead of the localName variable. wholeBodyActuators \u00b6 Instead of having different blocks for each kind of control mode, only one block is now present. The user can choose the control mode by double-clicking on it and selecting one of the possible modes (position, position direct, velocity and torques) wholeBodyModel \u00b6 It is divided into three subsections. The Joint Limits block is now moved into wholeBodyStates section. Dynamics \u00b6 the dJdq blocks have been moved into jacobians subsection; for mass matrix, generalized bias forces and centroidal momentum computation is now required to calculate explicitly the world-to-base homogeneous transformation matrix and the base velocity. Furthermore, the base frame pose and velocity and the joint configuration are now separate inputs. Jacobians \u00b6 There is now only one generic block for jacobians and one for dJdq calculation. The link with respect to which the Jacobian is computed is determined by its frame name as specified in the URDF model . As for the dynamics, the base pose and velocity and the joint position and velocity are required as input. Kinematics \u00b6 As for the section Jacobians , there is now only one generic block for forward kinematics computation. World-to-base homogeneous transformation matrix and joint position are the required input. wholeBodyStates \u00b6 As in the previous section, one generic block is used, from which the user can estimate joint position, velocity and acceleration and joint torques. The Joint Limits block is moved into this section.","title":"From WBI-Toolbox"},{"location":"Migration_from_WBI-Toolbox_1.0/#from-wbi-toolbox-to-wb-toolbox-2","text":"Given a simulink model with some WBI-Toolbox blocks inside, the general procedure is to substitute each block with the corresponding one from WB-Toolbox 2.0 . However, there are some things the user should take care while doing this operation. This guide points out the main differences between the two toolboxes. For more information about the WBI-Toolbox, please have a look at the WBI-Toolbox README . This guide follows the WBI and WB Toolbox blocks partitioning in Simulink library. It is divided in the following sections: Required variables Utilities wholeBodyActuators wholeBodyModel wholeBodyStates","title":"From WBI-Toolbox to WB-Toolbox 2.*"},{"location":"Migration_from_WBI-Toolbox_1.0/#required-variables","text":"As explained in the WB-Toolbox README , first of all the user should define the following variables: - WBT_modelName - WBT_wbiList - WBT_wbiFilename - WBT_robotName They have already meaningful default values. Nevertheless you should take a look at at least the following two variables: - WBT_modelname = 'matlabTorqueBalancing' or be careful that the default name does not conflicts with any other modules or YARP ports - WBT_wbiList = 'ROBOT_TORQUE_CONTROL_JOINTS_WITHOUT_PRONOSUP' if you simulate a 23-DoFs iCub robot","title":"Required variables"},{"location":"Migration_from_WBI-Toolbox_1.0/#floating-base-position-estimate","text":"In the WB-Toolbox the world-to-base homogeneous transformation matrix is not calculated inside each block, but it must be provided from the Simulink model as a block input. The world-to-base homogeneous transformation matrix is a 4x4 matrix that maps position and orientation of a rigid body from an initial frame of reference to another. For back-compatibility, the transformation happending under the hood in the WBI-Toolbox can be obtained using forward kinematics blocks as in the following example: where forward kinematics is used to compute the transformation matrices from world to the left foot and from world to the root link, while the desired transformation matrix is obtained as a matrices product, using the homogeneous transformation matrix properties.","title":"Floating base position estimate"},{"location":"Migration_from_WBI-Toolbox_1.0/#utilities","text":"In this section the user should note that: - the Minimum Jerk Trajectory Generator block has now only the reference trajectory as input. The initial value is automatically taken at startup. - Yarp Read and some other blocks require now the WBT_modelName instead of the localName variable.","title":"Utilities"},{"location":"Migration_from_WBI-Toolbox_1.0/#wholebodyactuators","text":"Instead of having different blocks for each kind of control mode, only one block is now present. The user can choose the control mode by double-clicking on it and selecting one of the possible modes (position, position direct, velocity and torques)","title":"wholeBodyActuators"},{"location":"Migration_from_WBI-Toolbox_1.0/#wholebodymodel","text":"It is divided into three subsections. The Joint Limits block is now moved into wholeBodyStates section.","title":"wholeBodyModel"},{"location":"Migration_from_WBI-Toolbox_1.0/#dynamics","text":"the dJdq blocks have been moved into jacobians subsection; for mass matrix, generalized bias forces and centroidal momentum computation is now required to calculate explicitly the world-to-base homogeneous transformation matrix and the base velocity. Furthermore, the base frame pose and velocity and the joint configuration are now separate inputs.","title":"Dynamics"},{"location":"Migration_from_WBI-Toolbox_1.0/#jacobians","text":"There is now only one generic block for jacobians and one for dJdq calculation. The link with respect to which the Jacobian is computed is determined by its frame name as specified in the URDF model . As for the dynamics, the base pose and velocity and the joint position and velocity are required as input.","title":"Jacobians"},{"location":"Migration_from_WBI-Toolbox_1.0/#kinematics","text":"As for the section Jacobians , there is now only one generic block for forward kinematics computation. World-to-base homogeneous transformation matrix and joint position are the required input.","title":"Kinematics"},{"location":"Migration_from_WBI-Toolbox_1.0/#wholebodystates","text":"As in the previous section, one generic block is used, from which the user can estimate joint position, velocity and acceleration and joint torques. The Joint Limits block is moved into this section.","title":"wholeBodyStates"},{"location":"about/","text":"WBT has been developed in the Dynamic Interaction Control research line at the Italian Institute of Technology . It was born from the ashes of robotology-playground/WBI-Toolbox . It is used extensively for controllers stored in robotology/whole-body-controllers . Maintainer \u00b6 Ferigo Diego ( @diegoferigo ) Contributors \u00b6 In alphabetical order: Eljaik Jorhabib ( @jeljaik ) Ferigo Diego ( @diegoferigo ) Nori Francesco ( @iron76 ) Pucci Daniele ( @DanielePucci ) Romano Francesco ( @francesco-romano ) Traversaro Silvio ( @traversaro ) Acknowledgments \u00b6 The development of WBT is supported by: FP7 EU projects CoDyCo (No. 600716 ICT 2011.2.1 Cognitive Systems and Robotics) H2020 EU projects AnDy (No. 731540 H2020-ICT-2016-1)","title":"About"},{"location":"about/#maintainer","text":"Ferigo Diego ( @diegoferigo )","title":"Maintainer"},{"location":"about/#contributors","text":"In alphabetical order: Eljaik Jorhabib ( @jeljaik ) Ferigo Diego ( @diegoferigo ) Nori Francesco ( @iron76 ) Pucci Daniele ( @DanielePucci ) Romano Francesco ( @francesco-romano ) Traversaro Silvio ( @traversaro )","title":"Contributors"},{"location":"about/#acknowledgments","text":"The development of WBT is supported by: FP7 EU projects CoDyCo (No. 600716 ICT 2011.2.1 Cognitive Systems and Robotics) H2020 EU projects AnDy (No. 731540 H2020-ICT-2016-1)","title":"Acknowledgments"},{"location":"install/","text":"Install \u00b6 Disclaimer WBT has been widely tested on Ubuntu 16:04 and Ubuntu 18.04 with Matlab R2017b . If you face any issue either with your OS or Matlab version, please submit an Issue . Requirements \u00b6 blockfactory YARP compiled as shared library (default behavior) iDynTree YCM Eigen3 Supported Operating Systems: Linux, macOS, Windows Development requirements \u00b6 Optional requirements \u00b6 iCub Gazebo Simulator gazebo_yarp_plugins qpOASES matio osqp-eigen Installation \u00b6 For a simplified installation procedure, jump to Install using the robotology-superbuild . Dependencies \u00b6 Install the required and the optional dependencies by following their installation instructions. These instructions need that blockfactory , YARP , iDynTree , YCM and Eigen3 packages can be found by CMake using find_package . Warning If an optional dependency is not found, the classes depending on it are not compiled. However, in the Simulink Library the blocks do not disappear. They will just not work, raising an appropriate error. Setup Matlab \u00b6 Matlab and Simulink are not required to build the WBT plugin. However, through blockfactory the plugin library shipped in this repository can be loaded inside a Simulink model. WBT provides a Simulink Library that exposes all the C++ blocks of the plugin to Simulink, wrapping them in user-friendly masks. Info Despite the blocks can be used directly from C++, this usage is not very user friendly. Simulink and alternative visual tools are very convenient solutions to connect blocks together, but nothing prevents using the provided blocks exploiting the blockfactory interfaces. From now on, we assume that you want to use Simulink since it is the most common use case. For developers \u00b6 Developers of WBT must have Simulink installed in order to operate on the provided Simulink Library. Make sure that CMake is able to find your Matlab installation , or manually set the Matlab_ROOT_DIR environment variable if needed. Download, build and install \u00b6 If all the dependencies are met, proceed with the following instructions: Commands Substitute to <install-prefix> the absolute path where you want to install the project. ````tab=\"GNU / Linux and macOS\" git clone robotology/wb-toolbox.git mkdir -p wb-toolbox/build && cd wb-toolbox/build cmake .. -DCMAKE_INSTALL_PREFIX= cmake --build . cmake --build . --target install ````tab=\"Windows\" git clone https://github.com/robotology/wb-toolbox.git mkdir -p wb-toolbox/build && cd wb-toolbox/build cmake .. -DCMAKE_INSTALL_PREFIX=<install-prefix> cmake --build . --config Release cmake --build . --config Release --target install Configuration \u00b6 Plugin \u00b6 In order to use Whole-Body Toolbox, the dynamic loader of the operating system should be able to find the plugin library. Add the folder <install-prefix>/lib/blockfactory to the following environment variable depending on the OS: GNU / Linux macOS Windows LD_LIBRARY_PATH DYLD_LIBRARY_PATH Path Matlab \u00b6 In order to use the WBT in Matlab you have to add some folders to the Matlab path. If you usually launch Matlab from the command line, exporting the following environment variable should be enough: export MATLABPATH = <install-prefix>/mex:<install-prefix>/share/WBToolbox:<install-prefix>/share/WBToolbox/images If, instead, you use the desktop launcher, a non-persistent Matlab configuration is the following: addpath ([ '<install-prefix>' / mex ]) addpath ( genpath ([ '<install-prefix>' / share / WBToolbox ])) We also provide for the latter scenario a persistent configuration of WBT . After the installation, run once the startup_wbitoolbox.m script that you can find in the <install-prefix>/share/WBToolbox directory. It will place a file pathdef.m in your userpath that loads the right variables to Matlab's environment. Note that this usage assumes that Matlab is always launched from the userpath folder . Environment \u00b6 Each robot that can be used with WBT has its own configuration files. WBT uses the YARP 's ResourceFinder for finding files in the file system. You should thus follow the related instructions to properly configure your installation (e.g. setting the YARP_DATA_DIRS and YARP_ROBOT_NAME variables). Install using the robotology-superbuild \u00b6 The robotology/robotology-superbuild provides an easy way for users to setup an environment by downloading, compiling, installing all the projects together. Follow the superbuild installation instructions and enable the ROBOTOLOGY_ENABLE_DYNAMICS profile. If WBT is not downloaded and built, check that ROBOTOLOGY_USES_MATLAB is ON and ROBOTOLOGY_NOT_USE_SIMULINK is OFF . The configuration of the environment should be straightforward following the Configure your environment and Matlab sections.","title":"Install"},{"location":"install/#install","text":"Disclaimer WBT has been widely tested on Ubuntu 16:04 and Ubuntu 18.04 with Matlab R2017b . If you face any issue either with your OS or Matlab version, please submit an Issue .","title":"Install"},{"location":"install/#requirements","text":"blockfactory YARP compiled as shared library (default behavior) iDynTree YCM Eigen3 Supported Operating Systems: Linux, macOS, Windows","title":"Requirements"},{"location":"install/#development-requirements","text":"","title":"Development requirements"},{"location":"install/#optional-requirements","text":"iCub Gazebo Simulator gazebo_yarp_plugins qpOASES matio osqp-eigen","title":"Optional requirements"},{"location":"install/#installation","text":"For a simplified installation procedure, jump to Install using the robotology-superbuild .","title":"Installation"},{"location":"install/#dependencies","text":"Install the required and the optional dependencies by following their installation instructions. These instructions need that blockfactory , YARP , iDynTree , YCM and Eigen3 packages can be found by CMake using find_package . Warning If an optional dependency is not found, the classes depending on it are not compiled. However, in the Simulink Library the blocks do not disappear. They will just not work, raising an appropriate error.","title":"Dependencies"},{"location":"install/#setup-matlab","text":"Matlab and Simulink are not required to build the WBT plugin. However, through blockfactory the plugin library shipped in this repository can be loaded inside a Simulink model. WBT provides a Simulink Library that exposes all the C++ blocks of the plugin to Simulink, wrapping them in user-friendly masks. Info Despite the blocks can be used directly from C++, this usage is not very user friendly. Simulink and alternative visual tools are very convenient solutions to connect blocks together, but nothing prevents using the provided blocks exploiting the blockfactory interfaces. From now on, we assume that you want to use Simulink since it is the most common use case.","title":"Setup Matlab"},{"location":"install/#for-developers","text":"Developers of WBT must have Simulink installed in order to operate on the provided Simulink Library. Make sure that CMake is able to find your Matlab installation , or manually set the Matlab_ROOT_DIR environment variable if needed.","title":"For developers"},{"location":"install/#download-build-and-install","text":"If all the dependencies are met, proceed with the following instructions: Commands Substitute to <install-prefix> the absolute path where you want to install the project. ````tab=\"GNU / Linux and macOS\" git clone robotology/wb-toolbox.git mkdir -p wb-toolbox/build && cd wb-toolbox/build cmake .. -DCMAKE_INSTALL_PREFIX= cmake --build . cmake --build . --target install ````tab=\"Windows\" git clone https://github.com/robotology/wb-toolbox.git mkdir -p wb-toolbox/build && cd wb-toolbox/build cmake .. -DCMAKE_INSTALL_PREFIX=<install-prefix> cmake --build . --config Release cmake --build . --config Release --target install","title":"Download, build and install"},{"location":"install/#configuration","text":"","title":"Configuration"},{"location":"install/#plugin","text":"In order to use Whole-Body Toolbox, the dynamic loader of the operating system should be able to find the plugin library. Add the folder <install-prefix>/lib/blockfactory to the following environment variable depending on the OS: GNU / Linux macOS Windows LD_LIBRARY_PATH DYLD_LIBRARY_PATH Path","title":"Plugin"},{"location":"install/#matlab","text":"In order to use the WBT in Matlab you have to add some folders to the Matlab path. If you usually launch Matlab from the command line, exporting the following environment variable should be enough: export MATLABPATH = <install-prefix>/mex:<install-prefix>/share/WBToolbox:<install-prefix>/share/WBToolbox/images If, instead, you use the desktop launcher, a non-persistent Matlab configuration is the following: addpath ([ '<install-prefix>' / mex ]) addpath ( genpath ([ '<install-prefix>' / share / WBToolbox ])) We also provide for the latter scenario a persistent configuration of WBT . After the installation, run once the startup_wbitoolbox.m script that you can find in the <install-prefix>/share/WBToolbox directory. It will place a file pathdef.m in your userpath that loads the right variables to Matlab's environment. Note that this usage assumes that Matlab is always launched from the userpath folder .","title":"Matlab"},{"location":"install/#environment","text":"Each robot that can be used with WBT has its own configuration files. WBT uses the YARP 's ResourceFinder for finding files in the file system. You should thus follow the related instructions to properly configure your installation (e.g. setting the YARP_DATA_DIRS and YARP_ROBOT_NAME variables).","title":"Environment"},{"location":"install/#install-using-the-robotology-superbuild","text":"The robotology/robotology-superbuild provides an easy way for users to setup an environment by downloading, compiling, installing all the projects together. Follow the superbuild installation instructions and enable the ROBOTOLOGY_ENABLE_DYNAMICS profile. If WBT is not downloaded and built, check that ROBOTOLOGY_USES_MATLAB is ON and ROBOTOLOGY_NOT_USE_SIMULINK is OFF . The configuration of the environment should be straightforward following the Configure your environment and Matlab sections.","title":"Install using the robotology-superbuild"},{"location":"license/","text":"LGPL v2.1 or any later version \u00b6 Copyright (C) 2019 Istituto Italiano di Tecnologia - iCub Facility This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA","title":"License"},{"location":"license/#lgpl-v21-or-any-later-version","text":"Copyright (C) 2019 Istituto Italiano di Tecnologia - iCub Facility This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA","title":"LGPL v2.1 or any later version"},{"location":"simulink_basic/","text":"Basic real-time Simulink model \u00b6 Example You can find the Simulink model created in this tutorial in the examples/ folder Let's start from a blank Simulink model. By default, Simulink selects the solver based on the requirements of the blocks that are part of the model. In most cases, a variable-step solver is selected by default. The aim of the Whole-Body toolbox is developing discrete-time robot controllers, and variable-steps solvers are not compatible with this kind of constraint. Open the model configuration, select a fixed-step solver, and set the step period for instance to 0.01 seconds: This configuration forces the simulation loop that computes the output of all blocks to run at 100 Hz. Simulating a discrete filter \u00b6 Now let's add a Discrete Filter block that is provided by WBT . This block exposes a C++ class that implements few discrete-time filters. We are interested in using a simple low-pass, configure the block mask to use a cut-off frequency equal to 10 Hz as follows: Now let's feed to the block two sine waves at different frequencies, one above and one below the cut-off frequency, plus a scope for visualising the signals: Press the Play button, wait the end of the simulation, and inspect the scope. You should obtain the following plot: As expected, the high-frequency component has been attenuated by the low-pass filter. Real-time simulation \u00b6 You might have noticed that the simulation runs accelerated. Despite the simulation time is 10 seconds, the simulation is executed to run as fast as possible. Robot controllers, beyond the need to run as discrete-time systems, have to be executed synchronously with the target platform. In this tutorial we will tie the simulation loop to the clock of the operating system. Insert a Real Time Synchronizer block to the model and configure it with the 0.01 period. If you run again the simulation, you will notice that it takes exactly 10 seconds. Note Note that this behaviour is that we expect to have when using real devices. However, before executing a Simulink model on the real robot, it should typically be tested in a simulated environment. We will cover the interfacing with Gazebo in another tutorial, but now you can already understand that in that case we need something similar to the Real Time Synchronizer that instead of using the real-time clock from the operating system uses the simulated clock.","title":"Basic real-time Simulink simulation"},{"location":"simulink_basic/#basic-real-time-simulink-model","text":"Example You can find the Simulink model created in this tutorial in the examples/ folder Let's start from a blank Simulink model. By default, Simulink selects the solver based on the requirements of the blocks that are part of the model. In most cases, a variable-step solver is selected by default. The aim of the Whole-Body toolbox is developing discrete-time robot controllers, and variable-steps solvers are not compatible with this kind of constraint. Open the model configuration, select a fixed-step solver, and set the step period for instance to 0.01 seconds: This configuration forces the simulation loop that computes the output of all blocks to run at 100 Hz.","title":"Basic real-time Simulink model"},{"location":"simulink_basic/#simulating-a-discrete-filter","text":"Now let's add a Discrete Filter block that is provided by WBT . This block exposes a C++ class that implements few discrete-time filters. We are interested in using a simple low-pass, configure the block mask to use a cut-off frequency equal to 10 Hz as follows: Now let's feed to the block two sine waves at different frequencies, one above and one below the cut-off frequency, plus a scope for visualising the signals: Press the Play button, wait the end of the simulation, and inspect the scope. You should obtain the following plot: As expected, the high-frequency component has been attenuated by the low-pass filter.","title":"Simulating a discrete filter"},{"location":"simulink_basic/#real-time-simulation","text":"You might have noticed that the simulation runs accelerated. Despite the simulation time is 10 seconds, the simulation is executed to run as fast as possible. Robot controllers, beyond the need to run as discrete-time systems, have to be executed synchronously with the target platform. In this tutorial we will tie the simulation loop to the clock of the operating system. Insert a Real Time Synchronizer block to the model and configure it with the 0.01 period. If you run again the simulation, you will notice that it takes exactly 10 seconds. Note Note that this behaviour is that we expect to have when using real devices. However, before executing a Simulink model on the real robot, it should typically be tested in a simulated environment. We will cover the interfacing with Gazebo in another tutorial, but now you can already understand that in that case we need something similar to the Real Time Synchronizer that instead of using the real-time clock from the operating system uses the simulated clock.","title":"Real-time simulation"},{"location":"simulink_gazebo/","text":"Simulink and Gazebo \u00b6 Example You can find the Simulink model created in this tutorial in the examples/ folder In this tutorial we show how to perform a co-simulation when both Simulink and Gazebo are involved. The two simulators by default use their own clock. In order to execute them synchronously, we need that: The clock used by the two simulators is unique One simulator is the master, and the other the slave We are not going too much in detail about the implementation of this co-simulation setup, but we try below to clarify the its architecture which starts to be more complex with respect to the previous tutorials. Sharing the clock \u00b6 The most intuitive choice of the clock for a co-simulation setup is using the time of the physic engine, that means Gazebo in this case. The robotology-superbuild already installed and configured the gazebo-yarp-plugins repository, that includes among other a plugin that streams the Gazebo clock to a YARP port. We will sync Simulink to use this network clock instead of the real-time clock, obtaining a synchronized co-simulation. This time, we need to execute yarpserver and launch Gazebo with gazebo -slibgazebo_yarp_clock.so . Master and Slave \u00b6 Once that the clocks are synced, we need to setup the master and the slave of the co-simulation . We provide a Simulator Synchronizer block that acts very similarly to the Real Time Synchronizer . In this case, beyond assuring that the fixed step duration is respected, the simulator sinchronizer also sends a signal to Gazebo triggering the physics simulation steps. Under this view, Simulink acts as a master and Gazebo as a slave. The network interface \u00b6 The model.urdf we used in the previous tutorial, beyond defining the description of the robot kinematics, also contains few gazebo plugins that expose a network interface of the simulated robot that matches the network interface of the real robot. Through these plugins we can get measurements and set references of a simulated robot by reading / writing YARP ports. This means that data shared between Simulink and Gazebo pass through the YARP middleware. Note Beyond mere IPC feature, this setup allows us to use the very same Simulink model to control both simulated and real robot, where the only difference between these two setups is the name of the YARP ports of the endpoint. Simulink model to actuate a robot joint \u00b6 Create a blank Simulink model and configure the solver to use a fixed-step as explained in the previous tutorial. Drop a Simulator Synchronizer block and a Configuration block. Fill the Configuration block as follows: Without entering in details, joints of YARP-based robots are typically grouped in sets called control boards . We want to control the r_elbow joint that is contained in the right_arm control board. Furthermore, we need to set the Robot Name which defines the name of the YARP ports of the endpoint (the simulated robot). Now the r_elbow is configured as controlled joint. Complete the following Simulink model that allows sending a sinusoidal reference in open loop: If the YARP server and Gazebo are running and everything else is configured properly, pressing the Play button should start the simulation. You should see that the right elbow of the robot moves as expected. You can also inspect if the trajectory is followed from the scope.","title":"Simulink and Gazebo"},{"location":"simulink_gazebo/#simulink-and-gazebo","text":"Example You can find the Simulink model created in this tutorial in the examples/ folder In this tutorial we show how to perform a co-simulation when both Simulink and Gazebo are involved. The two simulators by default use their own clock. In order to execute them synchronously, we need that: The clock used by the two simulators is unique One simulator is the master, and the other the slave We are not going too much in detail about the implementation of this co-simulation setup, but we try below to clarify the its architecture which starts to be more complex with respect to the previous tutorials.","title":"Simulink and Gazebo"},{"location":"simulink_gazebo/#sharing-the-clock","text":"The most intuitive choice of the clock for a co-simulation setup is using the time of the physic engine, that means Gazebo in this case. The robotology-superbuild already installed and configured the gazebo-yarp-plugins repository, that includes among other a plugin that streams the Gazebo clock to a YARP port. We will sync Simulink to use this network clock instead of the real-time clock, obtaining a synchronized co-simulation. This time, we need to execute yarpserver and launch Gazebo with gazebo -slibgazebo_yarp_clock.so .","title":"Sharing the clock"},{"location":"simulink_gazebo/#master-and-slave","text":"Once that the clocks are synced, we need to setup the master and the slave of the co-simulation . We provide a Simulator Synchronizer block that acts very similarly to the Real Time Synchronizer . In this case, beyond assuring that the fixed step duration is respected, the simulator sinchronizer also sends a signal to Gazebo triggering the physics simulation steps. Under this view, Simulink acts as a master and Gazebo as a slave.","title":"Master and Slave"},{"location":"simulink_gazebo/#the-network-interface","text":"The model.urdf we used in the previous tutorial, beyond defining the description of the robot kinematics, also contains few gazebo plugins that expose a network interface of the simulated robot that matches the network interface of the real robot. Through these plugins we can get measurements and set references of a simulated robot by reading / writing YARP ports. This means that data shared between Simulink and Gazebo pass through the YARP middleware. Note Beyond mere IPC feature, this setup allows us to use the very same Simulink model to control both simulated and real robot, where the only difference between these two setups is the name of the YARP ports of the endpoint.","title":"The network interface"},{"location":"simulink_gazebo/#simulink-model-to-actuate-a-robot-joint","text":"Create a blank Simulink model and configure the solver to use a fixed-step as explained in the previous tutorial. Drop a Simulator Synchronizer block and a Configuration block. Fill the Configuration block as follows: Without entering in details, joints of YARP-based robots are typically grouped in sets called control boards . We want to control the r_elbow joint that is contained in the right_arm control board. Furthermore, we need to set the Robot Name which defines the name of the YARP ports of the endpoint (the simulated robot). Now the r_elbow is configured as controlled joint. Complete the following Simulink model that allows sending a sinusoidal reference in open loop: If the YARP server and Gazebo are running and everything else is configured properly, pressing the Play button should start the simulation. You should see that the right elbow of the robot moves as expected. You can also inspect if the trajectory is followed from the scope.","title":"Simulink model to actuate a robot joint"},{"location":"simulink_model_blocks/","text":"Using model blocks \u00b6 Example You can find the Simulink model created in this tutorial in the examples/ folder Explore the urdf model \u00b6 In this tutorial we will use blocks that expose iDynTree functionalities to compute canonical rigid-body dynamics quantities. We will use the robot description of the humanoid iCub stored in icub-models . If your system is properly configured, iDynTree commands should be available in your path. First, locate the model.urdf file in your filesystem. Tip You should find it in <build>/install/share/iCub/robots/iCubGazeboV2_5/model.urdf , where <build> is the build folder of the superbuild repository. You should be able to execute the following command, that prints a recap of the urdf model listing joints, links, and frames: idyntree-model-info -p -m /absolute/path/to/model.urdf We are going to develop a Simulink model that computes in two ways the relative transform between root_link and r_hand . Configuration block \u00b6 Create a blank Simulink model and configure the solver to use a fixed-step as explained in the previous tutorial. The model is configured through a Configuration block. Select Mask as configuration source, and fill the Data tab as follows: The only important sections are the Urdf File containing the absolute path of the file model.urdf and the Controlled Joints that list the degrees of freedom of the robot we want to control. In this case we can operate on the joint angles of the three listed joints. There are other entries in this Configuration block, but they go beyond the scope of this tutorial since they are required to interface with a YARP robot in order to get measurement and set references. Note We used the absolute path to the urdf file to simplify the tutorial. On a typical system we use the filesystem resources provided by YARP to locate files, that allows us to store only the file name. iDynTree blocks \u00b6 Then, using the Relative Transform and Forward Kinematics block try to obtain the following model: The upper part of this models combines the output of two Forward Kinematics blocks to compute the {}^{r\\_hand}H_{root\\_link} {}^{r\\_hand}H_{root\\_link} transform, and compares the output with another block that uses the same model and directly provides the same transform. Three blocks generating random numbers define during every simulation loop a new joint configuration (associated to the three joints configured in the Configuration block). The two transform are then subtracted element-wise and summed. Pressing the Play button, the model parses the model stored in the urdf file, configures the joints angles, and provides at every simulation loop the requested transforms. We can visualize the difference of the two noticing the they match almost precisely (excluding small numerical rounding): Whole-Body Toolbox provides a many rigid-body dynamics resources that can be used to quickly build complex controllers, have a look for instance to Inverse Dynamics , Jacobian , Mass Matrix , and QP .","title":"Using model blocks"},{"location":"simulink_model_blocks/#using-model-blocks","text":"Example You can find the Simulink model created in this tutorial in the examples/ folder","title":"Using model blocks"},{"location":"simulink_model_blocks/#explore-the-urdf-model","text":"In this tutorial we will use blocks that expose iDynTree functionalities to compute canonical rigid-body dynamics quantities. We will use the robot description of the humanoid iCub stored in icub-models . If your system is properly configured, iDynTree commands should be available in your path. First, locate the model.urdf file in your filesystem. Tip You should find it in <build>/install/share/iCub/robots/iCubGazeboV2_5/model.urdf , where <build> is the build folder of the superbuild repository. You should be able to execute the following command, that prints a recap of the urdf model listing joints, links, and frames: idyntree-model-info -p -m /absolute/path/to/model.urdf We are going to develop a Simulink model that computes in two ways the relative transform between root_link and r_hand .","title":"Explore the urdf model"},{"location":"simulink_model_blocks/#configuration-block","text":"Create a blank Simulink model and configure the solver to use a fixed-step as explained in the previous tutorial. The model is configured through a Configuration block. Select Mask as configuration source, and fill the Data tab as follows: The only important sections are the Urdf File containing the absolute path of the file model.urdf and the Controlled Joints that list the degrees of freedom of the robot we want to control. In this case we can operate on the joint angles of the three listed joints. There are other entries in this Configuration block, but they go beyond the scope of this tutorial since they are required to interface with a YARP robot in order to get measurement and set references. Note We used the absolute path to the urdf file to simplify the tutorial. On a typical system we use the filesystem resources provided by YARP to locate files, that allows us to store only the file name.","title":"Configuration block"},{"location":"simulink_model_blocks/#idyntree-blocks","text":"Then, using the Relative Transform and Forward Kinematics block try to obtain the following model: The upper part of this models combines the output of two Forward Kinematics blocks to compute the {}^{r\\_hand}H_{root\\_link} {}^{r\\_hand}H_{root\\_link} transform, and compares the output with another block that uses the same model and directly provides the same transform. Three blocks generating random numbers define during every simulation loop a new joint configuration (associated to the three joints configured in the Configuration block). The two transform are then subtracted element-wise and summed. Pressing the Play button, the model parses the model stored in the urdf file, configures the joints angles, and provides at every simulation loop the requested transforms. We can visualize the difference of the two noticing the they match almost precisely (excluding small numerical rounding): Whole-Body Toolbox provides a many rigid-body dynamics resources that can be used to quickly build complex controllers, have a look for instance to Inverse Dynamics , Jacobian , Mass Matrix , and QP .","title":"iDynTree blocks"},{"location":"troubleshooting/","text":"Problems finding libraries and libstdc++ \u00b6 In case Matlab has trouble finding a specific library, a workaround is to launch it preloading the variable LD_PRELOAD (or DYLD_INSERT_LIBRARIES on macOS) with the full path of the missing library. On Linux you might have trouble with libstdc++.so since Matlab comes with its own. To use your system's libstdc++ you would need to launch Matlab with: LD_PRELOAD = /usr/lib/x86_64-linux-gnu/libstdc++.so.6 matlab The current version on Ubuntu 16:04 is libstdc++.so.6 , make sure this is the case also on your OS. Tip You could additionally create an alias to launch Matlab this way: alias matlab_wbt=\"cd ~/Documents/MATLAB && LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libstdc++.so.6 matlab\" Info Another solution involving the .matlab7rc.sh file can be found in https://github.com/robotology/codyco-superbuild/issues/141#issuecomment-257892256 .","title":"Troubleshooting"},{"location":"troubleshooting/#problems-finding-libraries-and-libstdc","text":"In case Matlab has trouble finding a specific library, a workaround is to launch it preloading the variable LD_PRELOAD (or DYLD_INSERT_LIBRARIES on macOS) with the full path of the missing library. On Linux you might have trouble with libstdc++.so since Matlab comes with its own. To use your system's libstdc++ you would need to launch Matlab with: LD_PRELOAD = /usr/lib/x86_64-linux-gnu/libstdc++.so.6 matlab The current version on Ubuntu 16:04 is libstdc++.so.6 , make sure this is the case also on your OS. Tip You could additionally create an alias to launch Matlab this way: alias matlab_wbt=\"cd ~/Documents/MATLAB && LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libstdc++.so.6 matlab\" Info Another solution involving the .matlab7rc.sh file can be found in https://github.com/robotology/codyco-superbuild/issues/141#issuecomment-257892256 .","title":"Problems finding libraries and libstdc++"},{"location":"tutorial_introduction/","text":"This set of tutorials introduce the basic usage of the Whole-Body Toolbox. They will teach you how to simulate a Simulink model for both simulation and real-time usage, covering also how to interface independently with iDynTree and YARP to respectively compute rigid-body dynamics quantities and interface with a robot. Note YARP and iDynTree are not both strictly required. Most of the code is independent from the two individually, and in theory these two components can be separated, providing the possibility for instance of using only the iDynTree blocks. Though, we use YARP to find files in the filesystem, including the urdf of the model. For this reason, we still require both to be installed in the system. Running the yarpserver is not necessary if YARP is not required during runtime. Tutorial 1: Basic real-time Simulink Model : This tutorial represents a primer for new users. It explains how to configure a Simulink model to be compatible with real-time usage and shows an example that involves signal filtering. Tutorial 2: Using model blocks : This tutorial introduces the usage of the iDynTree blocks used to compute canonical robotics quantities through rigid-body dynamics. It requires an existing urdf model. Tutorial 3: Simulink and Gazebo : This tutorial shows how to co-simulate the Simulink model interfacing with Gazebo. These tutorials assume that both blockfactory and wb-toolbox have been already installed and configured properly. Be sure that the Simulink Library contains the blocks provided by Whole-Body Toolbox: Warning To simplify the setup of the tutorials, we strongly recommend to install the Whole-Body Toolbox using the robotology-superbuild . We are going to need few more dependencies such that icub-models and gazebo-yarp-plugins that are automatically installed and configured by the superbuild.","title":"Introduction"}]}